using Irony.Ast;
using Irony.Interpreter;
using Irony.Parsing;
using Shakespeare.Text;
using Shakespeare.Utility;
using System.Collections.Generic;
using System.Linq;

namespace Shakespeare.Ast
{
    internal static class Constant
    {
        public static readonly int COMMENT_COLUMN = 40;
    }

    public class PlayNode : ShakespeareBaseAstNode
    {

        protected override object ReallyDoEvaluate(Irony.Interpreter.ScriptThread thread)
        {
            var sw = thread.tc().Writer;
            sw.WriteLine("/********************************************************************");
            sw.WriteLine(" *   This C program was generated by spl2c, the Shakespeare to C    *");
            sw.WriteLine(" *          converter by Jon Åslund and Karl Hasselström.           *");
            sw.WriteLine(" ********************************************************************/");
            sw.WriteLine("");
            sw.WriteLine("/* libspl definitions and function prototypes */");
            sw.WriteLine("#include \"spl.h\"");
            sw.WriteLine("");
            sw.WriteLine("int main(void)");
            sw.WriteLine("{");
            AstNode1.Evaluate(thread);  // Title
            sw.WriteLine();
            var cdl = AstNode2 as CharacterDeclarationListNode;
            foreach (var ch in cdl.Characters)
                sw.WriteLine(ch.Declaration);

            sw.WriteLine("\tint comp1, comp2;");
            sw.WriteLine("\tglobal_initialize();");
            foreach (var ch in cdl.Characters)
                sw.WriteLine(ch.Initialization);

            sw.WriteLine();
            sw.WriteLine();
            AstNode3.Evaluate(thread);
            sw.WriteLine("\treturn 0;");
            sw.WriteLine("}");
            sw.Flush();
            sw.Close();
            return sw;
        }
        public override string ToString()
        {
            return "Play";
        }
    }

    public class TitleNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            tw.WriteLine("/********************************************************************");
            tw.WriteLine("*");
            tw.WriteLine("{0,64}", Child1.Token.Text.ToUpper());
            tw.WriteLine("*");
            tw.WriteLine("*********************************************************************/");
            return this;
        }
    }

    public class CharacterDeclarationListNode : ListNode
    {
        public List<CharacterDeclarationNode> Characters { get; set; }
        public override void Init(AstContext context, Irony.Parsing.ParseTreeNode treeNode)
        {
            base.Init(context, treeNode);
            Characters = treeNode.ChildNodes.Select(cn => cn.AstNode as CharacterDeclarationNode).ToList();
        }
    }

    public class ActHeaderNode : ShakespeareBaseAstNode
    {
        string actnumber;

        public override void Init(AstContext context, ParseTreeNode treeNode)
        {
            base.Init(context, treeNode);
            actnumber = String1.str2varname();
        }

        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            Context.CurrentAct = actnumber;

            var tw = thread.tc().Writer;
            tw.WriteLine();
            tw.Write((Context.CurrentAct+":").PadRight(Constant.COMMENT_COLUMN));
            tw.WriteLine(AstNode2);

            return this;
        }
    }

    public class EnterNode : ShakespeareBaseAstNode
    {
        public override void Init(AstContext context, ParseTreeNode treeNode)
        {
            base.Init(context, treeNode);
            if (!Exist1)
            {
                context.AddMessage(Irony.ErrorLevel.Error, Location, @"""Enter"" missing character list");
                return;
            }
        }
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var cn = TreeNode.ChildNodes;
            if (Child1.AstNode is CharacterListNode)
                cn = Child1.ChildNodes;
            var tw = thread.tc().Writer;

            foreach (var ch in cn)
            {
                tw.WriteLine("\tenter_scene({0}, {1});", Location.Line, ch.AstNode.ToString().str2varname());
                Context.ActiveCharacters.Add(ch.AstNode as CharacterNode);
            }
            return this;
        }
    }

    public class ExitNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;

            var charList = new List<CharacterNode>();
            if (Exist1)
            {
                if (AstNode1 is CharacterNode)
                    charList.Add(AstNode1 as CharacterNode);
                else
                    (AstNode1 as CharacterListNode).Fill(charList);

                foreach (var chr in charList)
                {
                    tw.WriteLine("\texit_scene({0}, {1});", Location.Line, chr);
                    Context.ActiveCharacters.Remove(chr);
                }
            }
            else
            {
                tw.WriteLine("\texit_scene_all({0});", Location.Line);
                Context.ActiveCharacters.Clear();
            }

            return this;
        }
    }



    public class LineNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            tw.WriteLine();
            tw.WriteLine("\tactivate_character({0}, {1});", Location.Line, AstNode1);
            AstNode2.Evaluate(thread);
            return this;
        }
    }

    public class SentenceNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            if (AstNode1 is UnconditionalSentenceNode)
                AstNode1.Evaluate(thread);
            else
            {
                var tw = thread.tc().Writer;
                tw.WriteLine("\tif({0}) {{", AstNode1);
                AstNode2.Evaluate(thread);
                tw.WriteLine("\t}");
            }

            return this;
        }
    }

    public class UnconditionalSentenceNode : SelfNode   {}


    public class InOutNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            if (AstNode1 is OpenYourNode)
            {
                if (String2 == "heart (Keyword)")
                {
                    tw.WriteLine("\tint_output({0}, second_person);", Location.Line);
                }
                else  // Open Your Mind
                {
                    tw.WriteLine("\tchar_input({0}, second_person);", Location.Line);
                }
            }
            else if (String1 == "speak")
            {
                tw.WriteLine("\tchar_output({0}, second_person);", Location.Line);
            }
            else if (String1 == "listen to")
            {
                    tw.WriteLine("\tint_input({0}, second_person);", Location.Line);
            }
            return this;
        }
    }

    public class JumpNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            if (AstNode2 is SceneRomanNode)
                tw.WriteLine("\tgoto {0}_{1};", Context.CurrentAct, AstNode2.ToString().str2varname());
            else
                tw.WriteLine("\tgoto {0};", AstNode2.ToString().str2varname());

            return this;
        }

    }

    public class QuestionNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            tw.WriteLine("\tcomp1 = {0};", AstNode2);
            tw.WriteLine("\tcomp2 = {0};", AstNode4);
            tw.WriteLine("\ttruth_flag = {0};", AstNode3);

            return this;
        }
    }

    public class RecallNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            tw.WriteLine("\tpop({0}, second_person);", Location.Line);
            return this;
        }
    }

    public class RememberNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            tw.WriteLine("\tpush({0}, second_person, {1});", Location.Line, AstNode2);

            return this;
        }
    }

    public class StatementNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            if (AstNode1 is SecondPersonNode)
            {
                var tw = thread.tc().Writer;
                if (AstNode2 is BeNode)
                {
                    if (AstNode3 is ConstantNode)
                        tw.WriteLine("\tassign({0}, second_person, {1});", Location.Line, AstNode3);
                    else    // SECOND_PERSON BE Equality Value StatementSymbol 
                        tw.WriteLine("\tassign({0}, second_person, {1});", Location.Line, AstNode4);
  
                }
                else if (AstNode2 is UnarticulatedConstantNode)
                {
                    tw.WriteLine("\tassign({0}, second_person, {1});", Location.Line, AstNode2);

                }
            }

            return this;
        }

    }

    public class ConstantNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            if (AstNode1 is NothingNode)
                tw.Write("0");
            else  // astNode1 is Article, FirstPErson, SecondPerson, thirdPerson
                AstNode2.Evaluate(thread);

            return this;
        }
    }

    public class SceneHeaderNode : ShakespeareBaseAstNode
    {
        string scenenumber;

        public override void Init(AstContext context, ParseTreeNode treeNode)
        {
            base.Init(context, treeNode);
            scenenumber = String1.str2varname();
        }

        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            Context.CurrentScene = Context.CurrentAct + "_" + scenenumber;
            tw.WriteLine("{0}{1}", (Context.CurrentScene + ":").PadRight(Constant.COMMENT_COLUMN), AstNode2);
            return this;
        }
    }

    public class NegativeConstantNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            if (AstNode1 is NegativeNounNode)
                tw.Write("(-1)");
            else // astnode1 is NegativeAdjective or astnode1 is neutralAdjective
                tw.Write("2*{0}", AstNode2);
            return this;
        }
    }

    public class NonnegatedComparisonNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            tw.Write("({0})", AstNode1);
            return this;
        }
    }



    public class CharacterDeclarationNode : ShakespeareBaseAstNode 
    {
        public string Declaration { get; set; }
        public string Initialization { get; set; }

        public override void Init(AstContext context, ParseTreeNode treeNode)
        {
            base.Init(context, treeNode);
            Declaration = string.Format("\tCHARACTER*\t{0}=NULL;\t\t{1}", AstNode1, AstNode2);
            Initialization = string.Format("\t{0} = initialize_character(\"{0}\");", AstNode1);

        }
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            return this;
        }
    }

    public class CommentNode :ShakespeareBaseAstNode
    {
        public override string ToString()
        {
            return string.Format("/* {0} */\n", TreeNode.Token.Text);
        }
    }

    public class ComparisonNode : ShakespeareBaseAstNode 
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            if (AstNode1 is NonnegatedComparisonNode)
                AstNode1.Evaluate(thread);
            //                tw.WriteLine(AstNode1);
            else
            {
                var tw = thread.tc().Writer;
                tw.WriteLine("!{0}", AstNode2);
            }
            return this;
        }
    }

    public class ConditionalNode :ShakespeareBaseAstNode
    {
        public override string ToString()
        {
            if (Child1.Term.Name == "if so")
                return "truth_flag";
            else
                return "!truth_flag";   // if not
        }
    }

    public class ValueNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            if (AstNode1 is CharacterNode)
            {
                tw.Write(AstNode1);
                tw.Write("->value");
            }
            else if (AstNode1 is ConstantNode)
                AstNode1.Evaluate(thread);
            else if (AstNode1 is PronounNode)
            {
                tw.Write("value_of({0},{1})", Location.Line, AstNode1);
            }
            else if (AstNode1 is BinaryOperatorNode)
            {
                tw.Write(AstNode1.ToString(),Location.Line,  AstNode2, AstNode3);
            }
            else if (AstNode1 is UnaryOperatorNode)
            {
                AstNode1.Evaluate(thread);
                tw.Write((AstNode1 as UnaryOperatorNode).FormatString, AstNode2);
            }
            else
            {
                // error
            }
            return this;
        }

    }

    public class PronounNode : ShakespeareBaseAstNode
    {
        public override string ToString()
        {
            if (AstNode1 is FirstPersonNode || AstNode1 is FirstPersonReflexiveNode)
                return "first_person";
            else if (AstNode1 is SecondPersonNode || AstNode1 is SecondPersonReflexiveNode)
                return "second_person";
            return "ERROR";
        }
        
    }

    public class PositiveConstantNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            if (AstNode1 is PositiveNounNode)
                tw.Write("1");
            else
            {
                tw.Write("2*{0}", AstNode2);
            }
            return this;
        }
    }

    public class EqualityNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            tw.Write("comp1 == comp2");
            return this;
        }
    }

    public class ComparativeNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;
            if (AstNode1 is NegativeComparativeNode)
                tw.Write("comp1 < comp2");
            else  // PositiveComparativeNode
                tw.Write("comp1 > comp2");
            return this;
        }
    }

    public class NegativeComparativeNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            if (AstNode1 is NegativeComparativeTermNode)
                AstNode1.Evaluate(thread);
            else
                AstNode2.Evaluate(thread);

            return this;
        }
    }

    public class PositiveComparativeNode : ShakespeareBaseAstNode
    {
        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var term = AstNode1.Term;
            var strTerm = term != null ? term.ToString() : null;
            if (strTerm == "more" || strTerm == "less")
            {
                AstNode1.Evaluate(thread);
                var tw = thread.tc().Writer;
                tw.Write(' ');
                AstNode2.Evaluate(thread);
            }
            else
                AstNode1.Evaluate(thread);

            return this;
        }
    }

    public class BinaryOperatorNode : ShakespeareBaseAstNode
    {
        string format;

        public override void Init(AstContext context, ParseTreeNode treeNode)
        {
            base.Init(context, treeNode);
            var term = Child1.Term.Name;
            if (term == "the difference between")
                format = "int_sub({0}, {1}, {2})";
            else if (term == "the product of")
                format = "int_mul({0}, {1}, {2})";
            else if (term == "the quotient between")
                format = "int_div({0}, {1}, {2})";
            else if (term == "the remainder of the quotient between")
                format = "int_mod({0}, {1}, {2})";
            else if (term == "the sum of")
                format = "int_add({0}, {1}, {2})";
        }

        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            var tw = thread.tc().Writer;

            tw.Write(format, Location.Line, AstNode2, AstNode3);
            return this;
        }

        public override string ToString()
        {
            return format;
        }
    }

    public class UnaryOperatorNode : ShakespeareBaseAstNode
    {
        static readonly Dictionary<string, string> functionMap = new Dictionary<string, string>
        {
                {"the cube of", "int_cube"},
                {"the factorial of", "int_factorial"},
                {"the square of", "int_square"},
                {"the square root of", "int_sqrt"},
                {"twice", "int_twice"},
        };

        public string FormatString { get; set; }

        protected override object ReallyDoEvaluate(ScriptThread thread)
        {
            FormatString = string.Format("{0}({1},{{0}})", functionMap[String1], Location.Line);
            return this;
        }
    }



}

